Version 3.2 HI-TECH Software Intermediate Code
"86 lightmodbus/master.h
[s S21 `uc -> 9 `i `uc 1 ]
[n S21 . frame length ]
"109
[s S22 `uc -> 9 `i `uc 1 ]
[n S22 . frame length ]
"63 lightmodbus/master/mbcoils.h
[c E203 1 2 4 8 .. ]
[n E203 modbusDataType MODBUS_HOLDING_REGISTER MODBUS_INPUT_REGISTER MODBUS_COIL MODBUS_DISCRETE_INPUT  ]
"139 lightmodbus/master.h
[u S24 `uc -> 3 `i `ui -> >> -> 3 `i -> 1 `i `ux ]
[n S24 . coils regs ]
"129
[s S23 `uc 1 `ui 1 `ui 1 `uc 1 `E203 1 `uc 1 `S24 1 ]
[n S23 . address index count length type function . ]
"63 lightmodbus/master/mbcoils.h
[c E195 1 2 3 4 5 7 .. ]
[n E195 modbusExceptionCode MODBUS_EXCEP_ILLEGAL_FUNCTION MODBUS_EXCEP_ILLEGAL_ADDRESS MODBUS_EXCEP_ILLEGAL_VALUE MODBUS_EXCEP_SLAVE_FAILURE MODBUS_EXCEP_ACK MODBUS_EXCEP_NACK  ]
"184 lightmodbus/master.h
[s S25 `uc 1 `uc 1 `E195 1 ]
[n S25 . address function code ]
"63 lightmodbus/master/mbcoils.h
[c E174 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 .. ]
[n E174 modbusFrameError MODBUS_FERROR_OK MODBUS_FERROR_CRC MODBUS_FERROR_LENGTH MODBUS_FERROR_COUNT MODBUS_FERROR_VALUE MODBUS_FERROR_RANGE MODBUS_FERROR_NOSRC MODBUS_FERROR_NOREAD MODBUS_FERROR_NOWRITE MODBUS_FERROR_NOFUN MODBUS_FERROR_BADFUN MODBUS_FERROR_NULLFUN MODBUS_FERROR_MISM_FUN MODBUS_FERROR_MISM_ADDR MODBUS_FERROR_MISM_INDEX MODBUS_FERROR_MISM_COUNT MODBUS_FERROR_MISM_VALUE MODBUS_FERROR_MISM_MASK MODBUS_FERROR_BROADCAST  ]
"71 lightmodbus/master.h
[s S20 `uc 1 `S21 1 `S22 1 `S23 1 `S25 1 `E174 1 `E174 1 ]
[n S20 modbusMaster predictedResponseLength request response data exception parseError buildError ]
"63 lightmodbus/master/mbcoils.h
[c E164 0 1 2 3 4 5 6 0 .. ]
[n E164 modbusError MODBUS_ERROR_OK MODBUS_ERROR_EXCEPTION MODBUS_ERROR_ALLOC MODBUS_ERROR_OTHER MODBUS_ERROR_NULLPTR MODBUS_ERROR_PARSE MODBUS_ERROR_BUILD MODBUS_OK  ]
"47
[v _modbusBuildRequest0102 `(E164 ~T0 @X0 0 ef5`*S20`uc`uc`ui`ui ]
"34 app_sens_measure.h
[u S37 `Qui * / -> # `f `ui -> # `ui `ui -> -> 4 `i `ui `Qf -> 4 `i ]
[n S37 . word float_value ]
"27 app_modbus.c
[c E412 0 1 2 3 .. ]
[n E412 modbusRegisterQuery MODBUS_REGQ_R MODBUS_REGQ_W MODBUS_REGQ_R_CHECK MODBUS_REGQ_W_CHECK  ]
[v F419 `(ui ~T0 @X0 0 tf5`E412`E203`ui`ui`*v ]
"48 lightmodbus/parser.h
[s S4 `uc 1 `uc 1 ]
[n S4 . address function ]
"54
[s S5 `uc 1 `uc 1 `uc 1 `ui 1 ]
[n S5 . address function code crc ]
"62
[s S6 `uc 1 `uc 1 `ui 1 `ui 1 `ui 1 ]
[n S6 . address function index count crc ]
"71
[s S7 `uc 1 `uc 1 `uc 1 `uc -> 250 `i `ui 1 ]
[n S7 . address function length values crc ]
"80
[s S8 `uc 1 `uc 1 `ui 1 `ui 1 `ui 1 ]
[n S8 . address function index count crc ]
"89
[s S9 `uc 1 `uc 1 `uc 1 `ui -> 125 `i `ui 1 ]
[n S9 . address function length values crc ]
"99
[s S10 `uc 1 `uc 1 `ui 1 `ui 1 `ui 1 ]
[n S10 . address function index value crc ]
"108
[s S11 `uc 1 `uc 1 `ui 1 `ui 1 `ui 1 ]
[n S11 . address function index value crc ]
"117
[s S12 `uc 1 `uc 1 `ui 1 `ui 1 `ui 1 ]
[n S12 . address function index value crc ]
"126
[s S13 `uc 1 `uc 1 `ui 1 `ui 1 `ui 1 ]
[n S13 . address function index value crc ]
"135
[s S14 `uc 1 `uc 1 `ui 1 `ui 1 `uc 1 `uc -> 246 `i `ui 1 ]
[n S14 . address function index count length values crc ]
"146
[s S15 `uc 1 `uc 1 `ui 1 `ui 1 `ui 1 ]
[n S15 . address function index count crc ]
"155
[s S16 `uc 1 `uc 1 `ui 1 `ui 1 `uc 1 `ui -> 123 `i `ui 1 ]
[n S16 . address function index count length values crc ]
"166
[s S17 `uc 1 `uc 1 `ui 1 `ui 1 `ui 1 ]
[n S17 . address function index count crc ]
"175
[s S18 `uc 1 `uc 1 `ui 1 `ui 1 `ui 1 `ui 1 ]
[n S18 . address function index andmask ormask crc ]
"185
[s S19 `uc 1 `uc 1 `ui 1 `ui 1 `ui 1 `ui 1 ]
[n S19 . address function index andmask ormask crc ]
"43
[u S3 `uc -> 256 `i `QS4 1 `QS5 1 `QS6 1 `QS7 1 `QS8 1 `QS9 1 `QS10 1 `QS11 1 `QS12 1 `QS13 1 `QS14 1 `QS15 1 `QS16 1 `QS17 1 `QS18 1 `QS19 1 ]
[n S3 modbusParser frame _base exception request0102 response0102 request0304 response0304 request05 response05 request06 response06 request15 response15 request16 response16 request22 response22 ]
[v F408 `(E164 ~T0 @X0 0 tf2`*S28`*S3 ]
"51 lightmodbus/slave.h
[s S29 `uc 1 `*F408 1 ]
[n S29 modbusSlaveUserFunction function handler ]
"173
[s S30 `uc -> 23 `i `uc 1 ]
[n S30 . frame length ]
"196
[s S31 `uc -> 9 `i `uc 1 ]
[n S31 . frame length ]
"96
[s S28 `uc 1 `*F419 1 `*v 1 `ui 1 `ui 1 `*uc 1 `*uc 1 `*uc 1 `ui 1 `ui 1 `ui 1 `E195 1 `E174 1 `*S29 1 `ui 1 `S30 1 `S31 1 ]
[n S28 modbusSlave address registerCallback registerCallbackContext registerCount inputRegisterCount coils discreteInputs coilMask coilMaskLength coilCount discreteInputCount lastException parseError userFunctions userFunctionCount response request ]
"157 lightmodbus/lightmodbus.h
[v _modbusSwapEndian `(ui ~T0 @X0 0 ef1`ui ]
"82 app_modbus.c
[c E580 0 1 2 3 4 5 .. ]
[n E580 . BAUD_4800 BAUD_9600 BAUD_14400 BAUD_19200 BAUD_38400 BAUD_57600  ]
"88
[c E588 0 1 2 3 4 .. ]
[n E588 . TO_ONE_SEC TO_150_MSEC TO_300_MSEC TO_600_MSEC TO_TWO_SEC  ]
"100
[c E595 0 1 .. ]
[n E595 . EV_NORMAL EV_UP  ]
[c E599 0 1 2 .. ]
[n E599 . RLY_NONE RLY_OPEN RLY_SHORT  ]
"50 app_modbus.h
[s S39 `uc 1 `uc 1 `uc 1 `uc 1 `uc 1 `ul 1 `E595 1 `E599 1 `uc 1 ]
[n S39 . seq timeout event_flag fire_flag fire_retry event_timer last_event relay_status isWarmDone ]
"25 app_modbus.c
[v _g_modbus `S39 ~T0 @X0 0 e ]
"93 nvm.h
[s S35 `uc 1 `uc 1 `uc 1 `uc 1 `uc 1 `uc 1 `f 1 `ul 1 `uc 1 `uc 1 `uc 1 `uc 1 `ul 1 `Quc -> 8 `i ]
[n S35 . dummy sensing_on ctrl_master_mode ctrl_channel ctrl_slave_id ctrl_relay_no ctrl_ppm_max ctrl_holding_min byte_swap slave_id baudrate timeout buildtime serialNum ]
"91
[u S34 `Quc -> 30 `i `QS35 1 ]
[n S34 . byte . ]
"33
[s S33 `uc 1 `uc 1 `uc 1 `uc 1 `uc 1 `uc 1 `uc 1 `uc 1 `uc 1 `uc 1 `f 1 `f 1 `f 1 `f 1 `f 1 `f 1 `f 1 `ul 1 `ul 1 `Quc -> 10 `i `f 1 `ui 1 ]
[n S33 . supercap sensor_model adc_gain lmp_gain lmp_rload lmp_intZ filter_mode window_size temp_corf temp_compensate baseLine_uV span_uV CalibrationGas gas_slope calib_baseLine gasOffset tempOffset caltime usedtime sensor_name baseLine_temp check_sum ]
"31
[u S32 `Quc -> 62 `i `QS33 1 ]
[n S32 . byte . ]
"123
[s S36 `S34 1 `QS32 -> 2 `i ]
[n S36 . flash eeprm ]
"23 app_modbus.c
[v _g_nvm `S36 ~T0 @X0 0 e ]
"265 lightmodbus/slave.h
[v _modbusSlaveInit `(E164 ~T0 @X0 0 ef1`*S28 ]
"247 lightmodbus/master.h
[v _modbusMasterInit `(E164 ~T0 @X0 0 ef1`*S20 ]
"9 bsp/rs485.h
[v _rs485_init `(v ~T0 @X0 0 ef1`ul ]
"92 lightmodbus/master/mbcoils.h
[v _modbusBuildRequest05 `(E164 ~T0 @X0 0 ef4`*S20`uc`ui`ui ]
"11 bsp/rs485.h
[v _rs485_writeBytes `(v ~T0 @X0 0 ef2`*Cuc`Cuc ]
"286 app_modbus.c
[c E570 0 1 2 3 4 5 6 7 .. ]
[n E570 . MODBUS_INIT MODBUS_READY MODBUS_START MODBUS_TIMEOUT MODBUS_OUTPUT MODBUS_ERRPARSE MODBUS_EXCEPTION MODBUS_END  ]
"5 util/buffer.h
[s S2 `uc 1 `uc 1 `uc 1 `uc -> 64 `i ]
[n S2 buff_queue size read_pos write_pos buffer ]
"20
[v _buffer_de_queue_bool `(uc ~T0 @X0 0 ef2`*S2`*uc ]
"21 app_modbus.c
[v _g_modbus_queue `S2 ~T0 @X0 0 e ]
"240 lightmodbus/master.h
[v _modbusParseResponse `(E164 ~T0 @X0 0 ef1`*S20 ]
"254
[v _modbusMasterEnd `(E164 ~T0 @X0 0 ef1`*S20 ]
"258 lightmodbus/slave.h
[v _modbusParseRequest `(E164 ~T0 @X0 0 ef1`*S28 ]
"272
[v _modbusSlaveEnd `(E164 ~T0 @X0 0 ef1`*S28 ]
"447 app_modbus.c
[c E92 0 1 .. ]
[n E92 . SENSING_OFF SENSING_ON  ]
"448
[c E110 0 1 .. ]
[n E110 . MODBUS_SLAVE_MODE MODBUS_MASTER_MODE  ]
[; ;stdint.h: 13: typedef signed char int8_t;
[; ;stdint.h: 20: typedef signed int int16_t;
[; ;stdint.h: 28: typedef __int24 int24_t;
[; ;stdint.h: 36: typedef signed long int int32_t;
[; ;stdint.h: 52: typedef unsigned char uint8_t;
[; ;stdint.h: 58: typedef unsigned int uint16_t;
[; ;stdint.h: 65: typedef __uint24 uint24_t;
[; ;stdint.h: 72: typedef unsigned long int uint32_t;
[; ;stdint.h: 88: typedef signed char int_least8_t;
[; ;stdint.h: 96: typedef signed int int_least16_t;
[; ;stdint.h: 109: typedef __int24 int_least24_t;
[; ;stdint.h: 118: typedef signed long int int_least32_t;
[; ;stdint.h: 136: typedef unsigned char uint_least8_t;
[; ;stdint.h: 143: typedef unsigned int uint_least16_t;
[; ;stdint.h: 154: typedef __uint24 uint_least24_t;
[; ;stdint.h: 162: typedef unsigned long int uint_least32_t;
[; ;stdint.h: 181: typedef signed char int_fast8_t;
[; ;stdint.h: 188: typedef signed int int_fast16_t;
[; ;stdint.h: 200: typedef __int24 int_fast24_t;
[; ;stdint.h: 208: typedef signed long int int_fast32_t;
[; ;stdint.h: 224: typedef unsigned char uint_fast8_t;
[; ;stdint.h: 230: typedef unsigned int uint_fast16_t;
[; ;stdint.h: 240: typedef __uint24 uint_fast24_t;
[; ;stdint.h: 247: typedef unsigned long int uint_fast32_t;
[; ;stdint.h: 268: typedef int32_t intmax_t;
[; ;stdint.h: 282: typedef uint32_t uintmax_t;
[; ;stdint.h: 289: typedef int16_t intptr_t;
[; ;stdint.h: 294: typedef uint16_t uintptr_t;
[; ;stdbool.h: 15: typedef unsigned char bool;
[; ;xc8\pic\include\__size_t.h: 4: typedef unsigned size_t;
[; ;stdarg.h: 7: typedef void * va_list[1];
[; ;stdarg.h: 10: extern void * __va_start(void);
[; ;stdarg.h: 13: extern void * __va_arg(void *, ...);
[; ;stdio.h: 43: struct __prbuf
[; ;stdio.h: 44: {
[; ;stdio.h: 45: char * ptr;
[; ;stdio.h: 46: void (* func)(char);
[; ;stdio.h: 47: };
[; ;errno.h: 29: extern int errno;
[; ;conio.h: 12: extern void init_uart(void);
[; ;conio.h: 14: extern char getch(void);
[; ;conio.h: 15: extern char getche(void);
[; ;conio.h: 16: extern void putch(char);
[; ;conio.h: 17: extern void ungetch(char);
[; ;conio.h: 19: extern __bit kbhit(void);
[; ;conio.h: 23: extern char * cgets(char *);
[; ;conio.h: 24: extern void cputs(const char *);
[; ;stdio.h: 88: extern int cprintf(char *, ...);
[; ;stdio.h: 93: extern int _doprnt(struct __prbuf *, const register char *, register va_list);
[; ;stdio.h: 183: extern char * gets(char *);
[; ;stdio.h: 184: extern int puts(const char *);
[; ;stdio.h: 185: extern int scanf(const char *, ...) __attribute__((unsupported("scanf() is not supported by this compiler")));
[; ;stdio.h: 186: extern int sscanf(const char *, const char *, ...) __attribute__((unsupported("sscanf() is not supported by this compiler")));
[; ;stdio.h: 187: extern int vprintf(const char *, va_list) __attribute__((unsupported("vprintf() is not supported by this compiler")));
[; ;stdio.h: 188: extern int vsprintf(char *, const char *, va_list) __attribute__((unsupported("vsprintf() is not supported by this compiler")));
[; ;stdio.h: 189: extern int vscanf(const char *, va_list ap) __attribute__((unsupported("vscanf() is not supported by this compiler")));
[; ;stdio.h: 190: extern int vsscanf(const char *, const char *, va_list) __attribute__((unsupported("vsscanf() is not supported by this compiler")));
[; ;stdio.h: 194: extern int sprintf(char *, const char *, ...);
[; ;stdio.h: 195: extern int printf(const char *, ...);
[; ;board.h: 51: enum {
[; ;board.h: 52: SENSING_OFF,
[; ;board.h: 53: SENSING_ON
[; ;board.h: 54: };
[; ;board.h: 73: enum {
[; ;board.h: 74: CELSIUS,
[; ;board.h: 75: FAHRENHEIT
[; ;board.h: 76: };
[; ;board.h: 78: enum {
[; ;board.h: 79: RAW_MODE,
[; ;board.h: 80: FIL_MODE
[; ;board.h: 81: };
[; ;board.h: 83: enum {
[; ;board.h: 84: TEMP_NOT_COMPENSATION,
[; ;board.h: 85: TEMP_COMPENSATION
[; ;board.h: 86: };
[; ;board.h: 88: enum {
[; ;board.h: 89: NONE,
[; ;board.h: 90: NH3_100,
[; ;board.h: 91: H2S_50,
[; ;board.h: 92: EO,
[; ;board.h: 93: NH3_1000
[; ;board.h: 94: };
[; ;board.h: 96: enum {
[; ;board.h: 97: MODBUS_SLAVE_MODE,
[; ;board.h: 98: MODBUS_MASTER_MODE
[; ;board.h: 99: };
[; ;board.h: 221: void write_command(const uint8_t* buff);
[; ;board.h: 222: uint16_t* get_product_desc();
[; ;_string.h: 10: unsigned _strcpy(char* dest, const char* source);
[; ;_string.h: 11: void _strncpy(char *_to, const char *_from, int _n);
[; ;_string.h: 12: unsigned _strlen(const char* source);
[; ;_string.h: 13: void _strcat(char* dest, const char* source);
[; ;_string.h: 15: unsigned char _strncmp(const char* src1, const char* src2, int n, int i);
[; ;_string.h: 16: void _strclr(char* dest, int n);
[; ;_string.h: 18: unsigned char _isdigit(const char* src, int n);
[; ;buffer.h: 5: typedef struct buff_queue
[; ;buffer.h: 6: {
[; ;buffer.h: 7: uint8_t size;
[; ;buffer.h: 8: uint8_t read_pos;
[; ;buffer.h: 9: uint8_t write_pos;
[; ;buffer.h: 10: uint8_t buffer[64];
[; ;buffer.h: 11: } s_Queue;
[; ;buffer.h: 17: void buffer_init(s_Queue* queue);
[; ;buffer.h: 18: void buffer_en_queue(s_Queue* queue, uint8_t ch);
[; ;buffer.h: 19: uint8_t buffer_de_queue(s_Queue* queue);
[; ;buffer.h: 20: bool buffer_de_queue_bool(s_Queue* queue, uint8_t* ch);
[; ;rs485.h: 9: void rs485_init(uint32_t baudrate);
[; ;rs485.h: 10: bool rs485_is_writing(void);
[; ;rs485.h: 11: void rs485_writeBytes(const uint8_t* wrptr, const uint8_t len);
[; ;rs485.h: 12: bool rs485_readByte(uint8_t* byte);
[; ;lightmodbus.h: 49: typedef enum modbusError
[; ;lightmodbus.h: 50: {
[; ;lightmodbus.h: 51: MODBUS_ERROR_OK = 0,
[; ;lightmodbus.h: 64: MODBUS_ERROR_EXCEPTION = 1,
[; ;lightmodbus.h: 71: MODBUS_ERROR_ALLOC,
[; ;lightmodbus.h: 72: MODBUS_ERROR_OTHER,
[; ;lightmodbus.h: 73: MODBUS_ERROR_NULLPTR,
[; ;lightmodbus.h: 81: MODBUS_ERROR_PARSE,
[; ;lightmodbus.h: 82: MODBUS_ERROR_BUILD,
[; ;lightmodbus.h: 83: MODBUS_OK = MODBUS_ERROR_OK,
[; ;lightmodbus.h: 84: } ModbusError;
[; ;lightmodbus.h: 91: typedef enum modbusFrameError
[; ;lightmodbus.h: 92: {
[; ;lightmodbus.h: 93: MODBUS_FERROR_OK = MODBUS_OK,
[; ;lightmodbus.h: 94: MODBUS_FERROR_CRC,
[; ;lightmodbus.h: 95: MODBUS_FERROR_LENGTH,
[; ;lightmodbus.h: 96: MODBUS_FERROR_COUNT,
[; ;lightmodbus.h: 97: MODBUS_FERROR_VALUE,
[; ;lightmodbus.h: 98: MODBUS_FERROR_RANGE,
[; ;lightmodbus.h: 99: MODBUS_FERROR_NOSRC,
[; ;lightmodbus.h: 100: MODBUS_FERROR_NOREAD,
[; ;lightmodbus.h: 101: MODBUS_FERROR_NOWRITE,
[; ;lightmodbus.h: 102: MODBUS_FERROR_NOFUN,
[; ;lightmodbus.h: 103: MODBUS_FERROR_BADFUN,
[; ;lightmodbus.h: 104: MODBUS_FERROR_NULLFUN,
[; ;lightmodbus.h: 105: MODBUS_FERROR_MISM_FUN,
[; ;lightmodbus.h: 106: MODBUS_FERROR_MISM_ADDR,
[; ;lightmodbus.h: 107: MODBUS_FERROR_MISM_INDEX,
[; ;lightmodbus.h: 108: MODBUS_FERROR_MISM_COUNT,
[; ;lightmodbus.h: 109: MODBUS_FERROR_MISM_VALUE,
[; ;lightmodbus.h: 110: MODBUS_FERROR_MISM_MASK,
[; ;lightmodbus.h: 111: MODBUS_FERROR_BROADCAST
[; ;lightmodbus.h: 113: } ModbusFrameError;
[; ;lightmodbus.h: 118: typedef enum modbusExceptionCode
[; ;lightmodbus.h: 119: {
[; ;lightmodbus.h: 120: MODBUS_EXCEP_ILLEGAL_FUNCTION = 1,
[; ;lightmodbus.h: 121: MODBUS_EXCEP_ILLEGAL_ADDRESS = 2,
[; ;lightmodbus.h: 122: MODBUS_EXCEP_ILLEGAL_VALUE = 3,
[; ;lightmodbus.h: 123: MODBUS_EXCEP_SLAVE_FAILURE = 4,
[; ;lightmodbus.h: 124: MODBUS_EXCEP_ACK = 5,
[; ;lightmodbus.h: 125: MODBUS_EXCEP_NACK = 7
[; ;lightmodbus.h: 126: } ModbusExceptionCode;
[; ;lightmodbus.h: 131: typedef enum modbusDataType
[; ;lightmodbus.h: 132: {
[; ;lightmodbus.h: 133: MODBUS_HOLDING_REGISTER = 1,
[; ;lightmodbus.h: 134: MODBUS_INPUT_REGISTER = 2,
[; ;lightmodbus.h: 135: MODBUS_COIL = 4,
[; ;lightmodbus.h: 136: MODBUS_DISCRETE_INPUT = 8
[; ;lightmodbus.h: 137: } ModbusDataType;
[; ;lightmodbus.h: 145: extern uint16_t modbusBitsToBytes( uint16_t n );
[; ;lightmodbus.h: 157: extern uint16_t modbusSwapEndian( uint16_t data );
[; ;lightmodbus.h: 172: extern uint16_t modbusMatchEndian( uint16_t data );
[; ;lightmodbus.h: 183: extern uint8_t modbusMaskRead( const uint8_t *mask, uint16_t maskLength, uint16_t _bit );
[; ;lightmodbus.h: 194: extern uint8_t modbusMaskWrite( uint8_t *mask, uint16_t maskLength, uint16_t _bit, uint8_t value );
[; ;lightmodbus.h: 203: extern uint16_t modbusCRC( const uint8_t *data, uint16_t length );
[; ;parser.h: 43: typedef union modbusParser
[; ;parser.h: 44: {
[; ;parser.h: 45: uint8_t frame[256];
[; ;parser.h: 47: __pack struct
[; ;parser.h: 48: {
[; ;parser.h: 49: uint8_t address;
[; ;parser.h: 50: uint8_t function;
[; ;parser.h: 51: } _base;
[; ;parser.h: 53: __pack struct
[; ;parser.h: 54: {
[; ;parser.h: 55: uint8_t address;
[; ;parser.h: 56: uint8_t function;
[; ;parser.h: 57: uint8_t code;
[; ;parser.h: 58: uint16_t crc;
[; ;parser.h: 59: } exception;
[; ;parser.h: 61: __pack struct
[; ;parser.h: 62: {
[; ;parser.h: 63: uint8_t address;
[; ;parser.h: 64: uint8_t function;
[; ;parser.h: 65: uint16_t index;
[; ;parser.h: 66: uint16_t count;
[; ;parser.h: 67: uint16_t crc;
[; ;parser.h: 68: } request0102;
[; ;parser.h: 70: __pack struct
[; ;parser.h: 71: {
[; ;parser.h: 72: uint8_t address;
[; ;parser.h: 73: uint8_t function;
[; ;parser.h: 74: uint8_t length;
[; ;parser.h: 75: uint8_t values[250];
[; ;parser.h: 76: uint16_t crc;
[; ;parser.h: 77: } response0102;
[; ;parser.h: 79: __pack struct
[; ;parser.h: 80: {
[; ;parser.h: 81: uint8_t address;
[; ;parser.h: 82: uint8_t function;
[; ;parser.h: 83: uint16_t index;
[; ;parser.h: 84: uint16_t count;
[; ;parser.h: 85: uint16_t crc;
[; ;parser.h: 86: } request0304;
[; ;parser.h: 88: __pack struct
[; ;parser.h: 89: {
[; ;parser.h: 90: uint8_t address;
[; ;parser.h: 91: uint8_t function;
[; ;parser.h: 92: uint8_t length;
[; ;parser.h: 93: uint16_t values[125];
[; ;parser.h: 94: uint16_t crc;
[; ;parser.h: 95: } response0304;
[; ;parser.h: 98: __pack struct
[; ;parser.h: 99: {
[; ;parser.h: 100: uint8_t address;
[; ;parser.h: 101: uint8_t function;
[; ;parser.h: 102: uint16_t index;
[; ;parser.h: 103: uint16_t value;
[; ;parser.h: 104: uint16_t crc;
[; ;parser.h: 105: } request05;
[; ;parser.h: 107: __pack struct
[; ;parser.h: 108: {
[; ;parser.h: 109: uint8_t address;
[; ;parser.h: 110: uint8_t function;
[; ;parser.h: 111: uint16_t index;
[; ;parser.h: 112: uint16_t value;
[; ;parser.h: 113: uint16_t crc;
[; ;parser.h: 114: } response05;
[; ;parser.h: 116: __pack struct
[; ;parser.h: 117: {
[; ;parser.h: 118: uint8_t address;
[; ;parser.h: 119: uint8_t function;
[; ;parser.h: 120: uint16_t index;
[; ;parser.h: 121: uint16_t value;
[; ;parser.h: 122: uint16_t crc;
[; ;parser.h: 123: } request06;
[; ;parser.h: 125: __pack struct
[; ;parser.h: 126: {
[; ;parser.h: 127: uint8_t address;
[; ;parser.h: 128: uint8_t function;
[; ;parser.h: 129: uint16_t index;
[; ;parser.h: 130: uint16_t value;
[; ;parser.h: 131: uint16_t crc;
[; ;parser.h: 132: } response06;
[; ;parser.h: 134: __pack struct
[; ;parser.h: 135: {
[; ;parser.h: 136: uint8_t address;
[; ;parser.h: 137: uint8_t function;
[; ;parser.h: 138: uint16_t index;
[; ;parser.h: 139: uint16_t count;
[; ;parser.h: 140: uint8_t length;
[; ;parser.h: 141: uint8_t values[246];
[; ;parser.h: 142: uint16_t crc;
[; ;parser.h: 143: } request15;
[; ;parser.h: 145: __pack struct
[; ;parser.h: 146: {
[; ;parser.h: 147: uint8_t address;
[; ;parser.h: 148: uint8_t function;
[; ;parser.h: 149: uint16_t index;
[; ;parser.h: 150: uint16_t count;
[; ;parser.h: 151: uint16_t crc;
[; ;parser.h: 152: } response15;
[; ;parser.h: 154: __pack struct
[; ;parser.h: 155: {
[; ;parser.h: 156: uint8_t address;
[; ;parser.h: 157: uint8_t function;
[; ;parser.h: 158: uint16_t index;
[; ;parser.h: 159: uint16_t count;
[; ;parser.h: 160: uint8_t length;
[; ;parser.h: 161: uint16_t values[123];
[; ;parser.h: 162: uint16_t crc;
[; ;parser.h: 163: } request16;
[; ;parser.h: 165: __pack struct
[; ;parser.h: 166: {
[; ;parser.h: 167: uint8_t address;
[; ;parser.h: 168: uint8_t function;
[; ;parser.h: 169: uint16_t index;
[; ;parser.h: 170: uint16_t count;
[; ;parser.h: 171: uint16_t crc;
[; ;parser.h: 172: } response16;
[; ;parser.h: 174: __pack struct
[; ;parser.h: 175: {
[; ;parser.h: 176: uint8_t address;
[; ;parser.h: 177: uint8_t function;
[; ;parser.h: 178: uint16_t index;
[; ;parser.h: 179: uint16_t andmask;
[; ;parser.h: 180: uint16_t ormask;
[; ;parser.h: 181: uint16_t crc;
[; ;parser.h: 182: } request22;
[; ;parser.h: 184: __pack struct
[; ;parser.h: 185: {
[; ;parser.h: 186: uint8_t address;
[; ;parser.h: 187: uint8_t function;
[; ;parser.h: 188: uint16_t index;
[; ;parser.h: 189: uint16_t andmask;
[; ;parser.h: 190: uint16_t ormask;
[; ;parser.h: 191: uint16_t crc;
[; ;parser.h: 192: } response22;
[; ;parser.h: 193: } ModbusParser;
[; ;master.h: 71: typedef struct modbusMaster
[; ;master.h: 72: {
[; ;master.h: 74: uint8_t predictedResponseLength;
[; ;master.h: 85: struct
[; ;master.h: 86: {
[; ;master.h: 89: uint8_t frame[9];
[; ;master.h: 96: uint8_t length;
[; ;master.h: 97: } request;
[; ;master.h: 108: struct
[; ;master.h: 109: {
[; ;master.h: 112: uint8_t frame[9];
[; ;master.h: 119: uint8_t length;
[; ;master.h: 120: } response;
[; ;master.h: 128: struct
[; ;master.h: 129: {
[; ;master.h: 130: uint8_t address;
[; ;master.h: 131: uint16_t index;
[; ;master.h: 132: uint16_t count;
[; ;master.h: 133: uint8_t length;
[; ;master.h: 134: ModbusDataType type;
[; ;master.h: 135: uint8_t function;
[; ;master.h: 138: union
[; ;master.h: 139: {
[; ;master.h: 147: uint8_t coils[3];
[; ;master.h: 155: uint16_t regs[3 >> 1];
[; ;master.h: 156: };
[; ;master.h: 175: } data;
[; ;master.h: 183: struct
[; ;master.h: 184: {
[; ;master.h: 185: uint8_t address;
[; ;master.h: 186: uint8_t function;
[; ;master.h: 187: ModbusExceptionCode code;
[; ;master.h: 188: } exception;
[; ;master.h: 191: ModbusFrameError parseError;
[; ;master.h: 194: ModbusFrameError buildError;
[; ;master.h: 206: } ModbusMaster;
[; ;mbcoils.h: 47: extern ModbusError modbusBuildRequest0102( ModbusMaster *status, uint8_t function, uint8_t address, uint16_t index, uint16_t count );
[v F385 `(E164 ~T0 @X0 1 tf4`*S20`uc`ui`ui ]
"62 lightmodbus/master/mbcoils.h
[v _modbusBuildRequest01 `TF385 ~T0 @X0 1 s ]
"63
{
[; ;mbcoils.h: 62: static inline ModbusError modbusBuildRequest01( ModbusMaster *status, uint8_t address, uint16_t index, uint16_t count )
[; ;mbcoils.h: 63: { return modbusBuildRequest0102( (status), 1, (address), (index), (count) ); }
[e :U _modbusBuildRequest01 ]
"62
[v _status `*S20 ~T0 @X0 1 r1 ]
[v _address `uc ~T0 @X0 1 r2 ]
[v _index `ui ~T0 @X0 1 r3 ]
[v _count `ui ~T0 @X0 1 r4 ]
"63
[f ]
[e ) ( _modbusBuildRequest0102 (4 , , , , _status -> -> 1 `i `uc _address _index _count ]
[e $UE 26  ]
[e :UE 26 ]
}
[v F391 `(E164 ~T0 @X0 1 tf4`*S20`uc`ui`ui ]
"77
[v _modbusBuildRequest02 `TF391 ~T0 @X0 1 s ]
"78
{
[; ;mbcoils.h: 77: static inline ModbusError modbusBuildRequest02( ModbusMaster *status, uint8_t address, uint16_t index, uint16_t count )
[; ;mbcoils.h: 78: { return modbusBuildRequest0102( (status), 2, (address), (index), (count) ); }
[e :U _modbusBuildRequest02 ]
"77
[v _status `*S20 ~T0 @X0 1 r1 ]
[v _address `uc ~T0 @X0 1 r2 ]
[v _index `ui ~T0 @X0 1 r3 ]
[v _count `ui ~T0 @X0 1 r4 ]
"78
[f ]
[e ) ( _modbusBuildRequest0102 (4 , , , , _status -> -> 2 `i `uc _address _index _count ]
[e $UE 27  ]
[e :UE 27 ]
}
[; ;mbcoils.h: 92: extern ModbusError modbusBuildRequest05( ModbusMaster *status, uint8_t address, uint16_t index, uint16_t value );
[; ;master.h: 240: extern ModbusError modbusParseResponse( ModbusMaster *status );
[; ;master.h: 247: extern ModbusError modbusMasterInit( ModbusMaster *status );
[; ;master.h: 254: extern ModbusError modbusMasterEnd( ModbusMaster *status );
[; ;stddef.h: 6: typedef int ptrdiff_t;
[; ;slave.h: 45: struct modbusSlave;
[; ;slave.h: 51: typedef struct modbusSlaveUserFunction
[; ;slave.h: 52: {
[; ;slave.h: 53: uint8_t function;
[; ;slave.h: 60: ModbusError ( *handler )( struct modbusSlave *status, ModbusParser *parser );
[; ;slave.h: 61: } ModbusSlaveUserFunction;
[; ;slave.h: 73: typedef enum modbusRegisterQuery
[; ;slave.h: 74: {
[; ;slave.h: 75: MODBUS_REGQ_R,
[; ;slave.h: 76: MODBUS_REGQ_W,
[; ;slave.h: 77: MODBUS_REGQ_R_CHECK,
[; ;slave.h: 78: MODBUS_REGQ_W_CHECK
[; ;slave.h: 79: } ModbusRegisterQuery;
[; ;slave.h: 90: typedef uint16_t ( *ModbusRegisterCallbackFunction )( ModbusRegisterQuery query, ModbusDataType datatype, uint16_t index, uint16_t value, void *ctx );
[; ;slave.h: 96: typedef struct modbusSlave
[; ;slave.h: 97: {
[; ;slave.h: 98: uint8_t address;
[; ;slave.h: 107: ModbusRegisterCallbackFunction registerCallback;
[; ;slave.h: 114: void *registerCallbackContext;
[; ;slave.h: 124: uint16_t registerCount;
[; ;slave.h: 125: uint16_t inputRegisterCount;
[; ;slave.h: 129: uint8_t *coils;
[; ;slave.h: 130: uint8_t *discreteInputs;
[; ;slave.h: 131: uint8_t *coilMask;
[; ;slave.h: 132: uint16_t coilMaskLength;
[; ;slave.h: 134: uint16_t coilCount;
[; ;slave.h: 135: uint16_t discreteInputCount;
[; ;slave.h: 141: ModbusExceptionCode lastException;
[; ;slave.h: 149: ModbusFrameError parseError;
[; ;slave.h: 159: ModbusSlaveUserFunction *userFunctions;
[; ;slave.h: 160: uint16_t userFunctionCount;
[; ;slave.h: 172: struct
[; ;slave.h: 173: {
[; ;slave.h: 176: uint8_t frame[23];
[; ;slave.h: 183: uint8_t length;
[; ;slave.h: 184: } response;
[; ;slave.h: 195: struct
[; ;slave.h: 196: {
[; ;slave.h: 199: uint8_t frame[9];
[; ;slave.h: 206: uint8_t length;
[; ;slave.h: 207: } request;
[; ;slave.h: 209: } ModbusSlave;
[; ;slave.h: 231: extern ModbusError modbusBuildException( ModbusSlave *status, uint8_t function, ModbusExceptionCode code );
[; ;slave.h: 258: extern ModbusError modbusParseRequest( ModbusSlave *status );
[; ;slave.h: 265: extern ModbusError modbusSlaveInit( ModbusSlave *status );
[; ;slave.h: 272: extern ModbusError modbusSlaveEnd( ModbusSlave *status );
[; ;slave.h: 293: extern ModbusError modbusBuildExceptionErr( ModbusSlave *status, uint8_t function, ModbusExceptionCode code, ModbusFrameError parseError );
[; ;nvm.h: 31: typedef union {
[; ;nvm.h: 32: __pack uint8_t byte[62];
[; ;nvm.h: 33: __pack struct {
[; ;nvm.h: 34: uint8_t supercap;
[; ;nvm.h: 35: uint8_t sensor_model;
[; ;nvm.h: 36: uint8_t adc_gain;
[; ;nvm.h: 37: uint8_t lmp_gain;
[; ;nvm.h: 38: uint8_t lmp_rload;
[; ;nvm.h: 39: uint8_t lmp_intZ;
[; ;nvm.h: 40: uint8_t filter_mode;
[; ;nvm.h: 41: uint8_t window_size;
[; ;nvm.h: 42: uint8_t temp_corf;
[; ;nvm.h: 43: uint8_t temp_compensate;
[; ;nvm.h: 45: float baseLine_uV;
[; ;nvm.h: 46: float span_uV;
[; ;nvm.h: 47: float CalibrationGas;
[; ;nvm.h: 48: float gas_slope;
[; ;nvm.h: 49: float calib_baseLine;
[; ;nvm.h: 50: float gasOffset;
[; ;nvm.h: 51: float tempOffset;
[; ;nvm.h: 53: uint32_t caltime;
[; ;nvm.h: 54: uint32_t usedtime;
[; ;nvm.h: 56: __pack uint8_t sensor_name[10];
[; ;nvm.h: 58: float baseLine_temp;
[; ;nvm.h: 60: uint16_t check_sum;
[; ;nvm.h: 61: };
[; ;nvm.h: 62: } u_Eeprom_Nvm;
[; ;nvm.h: 91: typedef union {
[; ;nvm.h: 92: __pack uint8_t byte[30];
[; ;nvm.h: 93: __pack struct {
[; ;nvm.h: 94: uint8_t dummy;
[; ;nvm.h: 95: uint8_t sensing_on;
[; ;nvm.h: 97: uint8_t ctrl_master_mode;
[; ;nvm.h: 98: uint8_t ctrl_channel;
[; ;nvm.h: 99: uint8_t ctrl_slave_id;
[; ;nvm.h: 102: uint8_t ctrl_relay_no;
[; ;nvm.h: 103: float ctrl_ppm_max;
[; ;nvm.h: 104: uint32_t ctrl_holding_min;
[; ;nvm.h: 106: uint8_t byte_swap;
[; ;nvm.h: 107: uint8_t slave_id;
[; ;nvm.h: 108: uint8_t baudrate;
[; ;nvm.h: 109: uint8_t timeout;
[; ;nvm.h: 110: uint32_t buildtime;
[; ;nvm.h: 111: __pack uint8_t serialNum[8];
[; ;nvm.h: 112: };
[; ;nvm.h: 113: } u_Flash_Nvm;
[; ;nvm.h: 123: typedef struct {
[; ;nvm.h: 124: u_Flash_Nvm flash;
[; ;nvm.h: 125: __pack u_Eeprom_Nvm eeprm[2];
[; ;nvm.h: 126: } s_Nvm;
[; ;nvm.h: 132: uint16_t checksum(const uint8_t *data, uint16_t length);
[; ;nvm.h: 138: void nvm_init();
[; ;nvm.h: 139: void nvm_clear_channel(uint8_t channel);
[; ;nvm.h: 140: void nvm_clear(void);
[; ;nvm.h: 141: void nvm_clear_all();
[; ;nvm.h: 143: void nvm_sensor_type_channel(uint8_t chno, uint8_t sensor_model);
[; ;nvm.h: 145: bool nvm_write_eeprom_all(uint8_t channel);
[; ;nvm.h: 146: bool nvm_read_eeprom_all(uint8_t channel);
[; ;nvm.h: 148: bool nvm_write_flash_all(u_Flash_Nvm* flash);
[; ;nvm.h: 149: void nvm_read_flash_all(u_Flash_Nvm* flash);
[; ;app_sens_measure.h: 9: enum e_Measure_Seq {
[; ;app_sens_measure.h: 10: SENS_INIT,
[; ;app_sens_measure.h: 11: SENS_EEPRM_INIT,
[; ;app_sens_measure.h: 12: SENS_EEPRM_INIT_NEXT,
[; ;app_sens_measure.h: 13: SENS_SENSOR_INIT,
[; ;app_sens_measure.h: 14: SENS_SENSOR_INIT_NEXT,
[; ;app_sens_measure.h: 15: SENS_READY,
[; ;app_sens_measure.h: 16: SENS_CHANGE_TEMP,
[; ;app_sens_measure.h: 17: SENS_TEMP_MEASURE,
[; ;app_sens_measure.h: 18: SENS_CHANGE_GAS,
[; ;app_sens_measure.h: 19: SENS_GAS_MEASURE,
[; ;app_sens_measure.h: 20: SENS_APPLY,
[; ;app_sens_measure.h: 21: SENS_NEXT,
[; ;app_sens_measure.h: 22: SENS_WAIT,
[; ;app_sens_measure.h: 23: SENS_DISPLAY
[; ;app_sens_measure.h: 24: };
[; ;app_sens_measure.h: 26: enum e_SensorValue {
[; ;app_sens_measure.h: 27: LV_GAS_VOLT,
[; ;app_sens_measure.h: 28: LV_GAS_PPM,
[; ;app_sens_measure.h: 29: LV_TEMP
[; ;app_sens_measure.h: 30: };
[; ;app_sens_measure.h: 34: typedef union {
[; ;app_sens_measure.h: 35: __pack uint16_t word[(sizeof(float)/sizeof(uint16_t)) * 4];
[; ;app_sens_measure.h: 36: __pack float float_value[4];
[; ;app_sens_measure.h: 37: } u_SensorValue;
[; ;app_sens_measure.h: 39: typedef struct {
[; ;app_sens_measure.h: 40: uint8_t seq;
[; ;app_sens_measure.h: 41: uint8_t next_seq;
[; ;app_sens_measure.h: 42: uint8_t seq_count;
[; ;app_sens_measure.h: 44: bool existChannel[2];
[; ;app_sens_measure.h: 45: bool isChecksum[2];
[; ;app_sens_measure.h: 46: bool isSensorInit[2];
[; ;app_sens_measure.h: 48: } s_Sens_Measure;
[; ;app_sens_measure.h: 55: void sensMeasure_init();
[; ;app_sens_measure.h: 56: void sensMeasure_sensor_init();
[; ;app_sens_measure.h: 57: void sensMeasure_task();
[; ;app_modbus.h: 11: typedef enum {
[; ;app_modbus.h: 12: MODBUS_INIT,
[; ;app_modbus.h: 13: MODBUS_READY,
[; ;app_modbus.h: 14: MODBUS_START,
[; ;app_modbus.h: 15: MODBUS_TIMEOUT,
[; ;app_modbus.h: 16: MODBUS_OUTPUT,
[; ;app_modbus.h: 17: MODBUS_ERRPARSE,
[; ;app_modbus.h: 18: MODBUS_EXCEPTION,
[; ;app_modbus.h: 19: MODBUS_END
[; ;app_modbus.h: 20: } e_Modbus_Seq;
[; ;app_modbus.h: 22: typedef enum {
[; ;app_modbus.h: 23: BAUD_4800,
[; ;app_modbus.h: 24: BAUD_9600,
[; ;app_modbus.h: 25: BAUD_14400,
[; ;app_modbus.h: 26: BAUD_19200,
[; ;app_modbus.h: 27: BAUD_38400,
[; ;app_modbus.h: 28: BAUD_57600
[; ;app_modbus.h: 29: } e_Baudrate;
[; ;app_modbus.h: 31: typedef enum {
[; ;app_modbus.h: 32: TO_ONE_SEC,
[; ;app_modbus.h: 33: TO_150_MSEC,
[; ;app_modbus.h: 34: TO_300_MSEC,
[; ;app_modbus.h: 35: TO_600_MSEC,
[; ;app_modbus.h: 36: TO_TWO_SEC
[; ;app_modbus.h: 37: } e_Timeout;
[; ;app_modbus.h: 39: typedef enum {
[; ;app_modbus.h: 40: EV_NORMAL,
[; ;app_modbus.h: 41: EV_UP
[; ;app_modbus.h: 42: } e_EventType;
[; ;app_modbus.h: 44: typedef enum {
[; ;app_modbus.h: 45: RLY_NONE,
[; ;app_modbus.h: 46: RLY_OPEN,
[; ;app_modbus.h: 47: RLY_SHORT
[; ;app_modbus.h: 48: } e_RelayStatus;
[; ;app_modbus.h: 50: typedef struct {
[; ;app_modbus.h: 51: uint8_t seq;
[; ;app_modbus.h: 52: uint8_t timeout;
[; ;app_modbus.h: 55: bool event_flag;
[; ;app_modbus.h: 56: bool fire_flag;
[; ;app_modbus.h: 57: uint8_t fire_retry;
[; ;app_modbus.h: 58: uint32_t event_timer;
[; ;app_modbus.h: 59: e_EventType last_event;
[; ;app_modbus.h: 60: e_RelayStatus relay_status;
[; ;app_modbus.h: 61: bool isWarmDone;
[; ;app_modbus.h: 63: } s_Modbus;
[; ;app_modbus.h: 69: void modbus_init(void);
[; ;app_modbus.h: 70: void modbus_task(void);
[; ;app_modbus.h: 72: void modbus_set_register(const uint16_t* reg);
[; ;app_modbus.h: 73: void modbus_set_swap(bool isSwap);
[; ;app_modbus.h: 75: uint32_t modbus_get_baudrate(uint8_t baud);
[; ;app_modbus.h: 76: uint8_t modbus_get_timeout(uint8_t to);
"18 app_modbus.c
[v _g_modbus_value `S37 ~T0 @X0 1 e ]
[; ;app_modbus.c: 18: u_SensorValue g_modbus_value;
[; ;app_modbus.c: 21: extern s_Queue g_modbus_queue;
[; ;app_modbus.c: 23: extern s_Nvm g_nvm;
[; ;app_modbus.c: 25: extern s_Modbus g_modbus;
"27
[v _g_slave `S28 ~T0 @X0 1 e ]
[; ;app_modbus.c: 27: ModbusSlave g_slave;
"28
[v _g_master `S20 ~T0 @X0 1 e ]
[; ;app_modbus.c: 28: ModbusMaster g_master;
"30
[v _g_pRegs `*ui ~T0 @X0 1 e ]
[; ;app_modbus.c: 30: uint16_t* g_pRegs;
"31
[v _g_swap `uc ~T0 @X0 1 e ]
[; ;app_modbus.c: 31: bool g_swap;
"33
[v _g_timeout_count `Vuc ~T0 @X0 1 e ]
[; ;app_modbus.c: 33: volatile uint8_t g_timeout_count;
"34
[v _g_relay_sec_count `Vui ~T0 @X0 1 e ]
[; ;app_modbus.c: 34: volatile uint16_t g_relay_sec_count;
"35
[v _g_relay_status_count `Vui ~T0 @X0 1 e ]
[; ;app_modbus.c: 35: volatile uint16_t g_relay_status_count;
"43
[v _g_baudrate `Cul ~T0 @X0 -> 6 `i e ]
[i _g_baudrate
:U ..
"44
-> -> -> 4800 `i `l `ul
-> -> -> 9600 `i `l `ul
-> -> -> 14400 `i `l `ul
-> -> -> 19200 `i `l `ul
-> -> 38400 `l `ul
"45
-> -> 57600 `l `ul
..
]
[; ;app_modbus.c: 43: const uint32_t g_baudrate[6] = {
[; ;app_modbus.c: 44: 4800, 9600, 14400, 19200, 38400, 57600
[; ;app_modbus.c: 45: };
"48
[v _g_timeout `Cuc ~T0 @X0 -> 5 `i e ]
[i _g_timeout
:U ..
"49
-> -> 100 `i `uc
-> -> 15 `i `uc
-> -> 30 `i `uc
-> -> 60 `i `uc
"50
-> -> 200 `i `uc
..
]
[; ;app_modbus.c: 48: const uint8_t g_timeout[5] = {
[; ;app_modbus.c: 49: 100, 15, 30, 60, 200
[; ;app_modbus.c: 50: };
"52
[v _rcallback `(ui ~T0 @X0 1 ef5`E412`E203`ui`ui`*v ]
"53
{
[; ;app_modbus.c: 52: uint16_t rcallback(ModbusRegisterQuery query, ModbusDataType datatype, uint16_t index, uint16_t value, void *ctx)
[; ;app_modbus.c: 53: {
[e :U _rcallback ]
"52
[v _query `E412 ~T0 @X0 1 r1 ]
[v _datatype `E203 ~T0 @X0 1 r2 ]
[v _index `ui ~T0 @X0 1 r3 ]
[v _value `ui ~T0 @X0 1 r4 ]
[v _ctx `*v ~T0 @X0 1 r5 ]
"53
[f ]
[; ;app_modbus.c: 54: if(query == MODBUS_REGQ_R_CHECK)
"54
[e $ ! == -> _query `i -> . `E412 2 `i 41  ]
[; ;app_modbus.c: 55: return 1;
"55
[e ) -> -> 1 `i `ui ]
[e $UE 40  ]
[e :U 41 ]
[; ;app_modbus.c: 56: if(query == MODBUS_REGQ_R)
"56
[e $ ! == -> _query `i -> . `E412 0 `i 42  ]
[; ;app_modbus.c: 57: {
"57
{
[; ;app_modbus.c: 58: if(datatype == MODBUS_HOLDING_REGISTER)
"58
[e $ ! == -> _datatype `i -> . `E203 0 `i 43  ]
[; ;app_modbus.c: 59: {
"59
{
[; ;app_modbus.c: 60: if (g_swap) {
"60
[e $ ! != -> _g_swap `i -> -> -> 0 `i `uc `i 44  ]
{
[; ;app_modbus.c: 61: return modbusSwapEndian(g_pRegs[index]);
"61
[e ) ( _modbusSwapEndian (1 *U + _g_pRegs * -> _index `ux -> -> # *U _g_pRegs `ui `ux ]
[e $UE 40  ]
"62
}
[; ;app_modbus.c: 62: } else {
[e $U 45  ]
[e :U 44 ]
{
[; ;app_modbus.c: 63: return g_pRegs[index];
"63
[e ) *U + _g_pRegs * -> _index `ux -> -> # *U _g_pRegs `ui `ux ]
[e $UE 40  ]
"64
}
[e :U 45 ]
"65
}
[e :U 43 ]
"66
}
[e :U 42 ]
[; ;app_modbus.c: 64: }
[; ;app_modbus.c: 65: }
[; ;app_modbus.c: 66: }
[; ;app_modbus.c: 67: return 0;
"67
[e ) -> -> 0 `i `ui ]
[e $UE 40  ]
[; ;app_modbus.c: 68: }
"68
[e :UE 40 ]
}
"70
[v _modbus_set_register `(v ~T0 @X0 1 ef1`*Cui ]
"71
{
[; ;app_modbus.c: 70: void modbus_set_register(const uint16_t* reg)
[; ;app_modbus.c: 71: {
[e :U _modbus_set_register ]
"70
[v _reg `*Cui ~T0 @X0 1 r1 ]
"71
[f ]
[; ;app_modbus.c: 72: g_pRegs = (uint16_t*)reg;
"72
[e = _g_pRegs -> _reg `*ui ]
[; ;app_modbus.c: 73: }
"73
[e :UE 46 ]
}
"75
[v _modbus_set_swap `(v ~T0 @X0 1 ef1`uc ]
"76
{
[; ;app_modbus.c: 75: void modbus_set_swap(bool isSwap)
[; ;app_modbus.c: 76: {
[e :U _modbus_set_swap ]
"75
[v _isSwap `uc ~T0 @X0 1 r1 ]
"76
[f ]
[; ;app_modbus.c: 77: g_swap = isSwap;
"77
[e = _g_swap _isSwap ]
[; ;app_modbus.c: 78: }
"78
[e :UE 47 ]
}
"80
[v _modbus_get_baudrate `(ul ~T0 @X0 1 ef1`uc ]
"81
{
[; ;app_modbus.c: 80: uint32_t modbus_get_baudrate(uint8_t baud)
[; ;app_modbus.c: 81: {
[e :U _modbus_get_baudrate ]
"80
[v _baud `uc ~T0 @X0 1 r1 ]
"81
[f ]
[; ;app_modbus.c: 82: if (baud > BAUD_57600) baud = BAUD_57600;
"82
[e $ ! > -> _baud `i -> . `E580 5 `i 49  ]
[e = _baud -> . `E580 5 `uc ]
[e :U 49 ]
[; ;app_modbus.c: 83: return g_baudrate[baud];
"83
[e ) *U + &U _g_baudrate * -> _baud `ux -> -> # *U &U _g_baudrate `ui `ux ]
[e $UE 48  ]
[; ;app_modbus.c: 84: }
"84
[e :UE 48 ]
}
"86
[v _modbus_get_timeout `(uc ~T0 @X0 1 ef1`uc ]
"87
{
[; ;app_modbus.c: 86: uint8_t modbus_get_timeout(uint8_t to)
[; ;app_modbus.c: 87: {
[e :U _modbus_get_timeout ]
"86
[v _to `uc ~T0 @X0 1 r1 ]
"87
[f ]
[; ;app_modbus.c: 88: if (to > TO_TWO_SEC) to = TO_TWO_SEC;
"88
[e $ ! > -> _to `i -> . `E588 4 `i 51  ]
[e = _to -> . `E588 4 `uc ]
[e :U 51 ]
[; ;app_modbus.c: 89: return g_timeout[to];
"89
[e ) *U + &U _g_timeout * -> _to `ux -> -> # *U &U _g_timeout `ui `ux ]
[e $UE 50  ]
[; ;app_modbus.c: 90: }
"90
[e :UE 50 ]
}
"92
[v _modbus_init `(v ~T0 @X0 1 ef ]
"93
{
[; ;app_modbus.c: 92: void modbus_init(void)
[; ;app_modbus.c: 93: {
[e :U _modbus_init ]
[f ]
[; ;app_modbus.c: 97: g_relay_sec_count = 0;
"97
[e = _g_relay_sec_count -> -> 0 `i `ui ]
[; ;app_modbus.c: 98: g_relay_status_count = 0;
"98
[e = _g_relay_status_count -> -> 0 `i `ui ]
[; ;app_modbus.c: 100: g_modbus.event_flag = 0;
"100
[e = . _g_modbus 2 -> -> 0 `i `uc ]
[; ;app_modbus.c: 101: g_modbus.fire_flag = 0;
"101
[e = . _g_modbus 3 -> -> 0 `i `uc ]
[; ;app_modbus.c: 102: g_modbus.fire_retry = 0;
"102
[e = . _g_modbus 4 -> -> 0 `i `uc ]
[; ;app_modbus.c: 103: g_modbus.last_event = EV_NORMAL;
"103
[e = . _g_modbus 6 . `E595 0 ]
[; ;app_modbus.c: 104: g_modbus.event_timer = 0;
"104
[e = . _g_modbus 5 -> -> -> 0 `i `l `ul ]
[; ;app_modbus.c: 105: g_modbus.relay_status = RLY_NONE;
"105
[e = . _g_modbus 7 . `E599 0 ]
[; ;app_modbus.c: 106: g_modbus.isWarmDone = 0;
"106
[e = . _g_modbus 8 -> -> 0 `i `uc ]
[; ;app_modbus.c: 108: g_slave.address = g_nvm.flash.slave_id;
"108
[e = . _g_slave 0 . . . _g_nvm 0 1 9 ]
[; ;app_modbus.c: 109: g_slave.registerCallback = rcallback;
"109
[e = . _g_slave 1 &U _rcallback ]
[; ;app_modbus.c: 110: g_slave.registerCount = (sizeof(float) * 4) / sizeof(uint16_t);
"110
[e = . _g_slave 3 / * -> # `f `ui -> -> 4 `i `ui -> # `ui `ui ]
[; ;app_modbus.c: 112: modbus_set_register((uint16_t*)g_modbus_value.word);
"112
[e ( _modbus_set_register (1 -> -> &U . _g_modbus_value 0 `*ui `*Cui ]
[; ;app_modbus.c: 114: modbusSlaveInit(&g_slave);
"114
[e ( _modbusSlaveInit (1 &U _g_slave ]
[; ;app_modbus.c: 115: modbusMasterInit(&g_master);
"115
[e ( _modbusMasterInit (1 &U _g_master ]
[; ;app_modbus.c: 117: g_swap = g_nvm.flash.byte_swap;
"117
[e = _g_swap . . . _g_nvm 0 1 8 ]
[; ;app_modbus.c: 119: g_timeout_count = 0;
"119
[e = _g_timeout_count -> -> 0 `i `uc ]
[; ;app_modbus.c: 120: g_modbus.timeout = modbus_get_timeout(g_nvm.flash.timeout);
"120
[e = . _g_modbus 1 ( _modbus_get_timeout (1 . . . _g_nvm 0 1 11 ]
[; ;app_modbus.c: 122: rs485_init(modbus_get_baudrate(g_nvm.flash.baudrate));
"122
[e ( _rs485_init (1 ( _modbus_get_baudrate (1 . . . _g_nvm 0 1 10 ]
[; ;app_modbus.c: 123: }
"123
[e :UE 52 ]
}
"126
[v _modbus_relay_ouput `(uc ~T0 @X0 1 sf2`Cuc`Cuc ]
"127
{
[; ;app_modbus.c: 126: static bool modbus_relay_ouput(const uint8_t relay_idx, const bool on)
[; ;app_modbus.c: 127: {
[e :U _modbus_relay_ouput ]
"126
[v _relay_idx `Cuc ~T0 @X0 1 r1 ]
[v _on `Cuc ~T0 @X0 1 r2 ]
"127
[f ]
[; ;app_modbus.c: 128: g_modbus.relay_status = RLY_NONE;
"128
[e = . _g_modbus 7 . `E599 0 ]
"129
[v _data `ui ~T0 @X0 1 a ]
[; ;app_modbus.c: 129: uint16_t data = (on == 1)?0xff00:0x0000;
[e = _data ? == -> _on `i -> 1 `i : -> 65280 `ui -> -> 0 `i `ui ]
"130
[v _idx `uc ~T0 @X0 1 a ]
[; ;app_modbus.c: 130: uint8_t idx = ((relay_idx - 1) < 0)?0:(relay_idx - 1);
[e = _idx -> ? < - -> _relay_idx `i -> 1 `i -> 0 `i : -> 0 `i - -> _relay_idx `i -> 1 `i `uc ]
"131
[v _err `E164 ~T0 @X0 1 a ]
[; ;app_modbus.c: 131: ModbusError err = modbusBuildRequest05(&g_master, g_nvm.flash.ctrl_slave_id,
[; ;app_modbus.c: 132: 600 + idx, data);
"132
[e = _err ( _modbusBuildRequest05 (4 , , , &U _g_master . . . _g_nvm 0 1 4 -> + -> 600 `i -> _idx `i `ui _data ]
[; ;app_modbus.c: 133: if (err != MODBUS_OK) {
"133
[e $ ! != -> _err `i -> . `E164 7 `i 54  ]
{
[; ;app_modbus.c: 134: return 0;
"134
[e ) -> -> 0 `i `uc ]
[e $UE 53  ]
"135
}
[e :U 54 ]
[; ;app_modbus.c: 135: }
[; ;app_modbus.c: 141: rs485_writeBytes(g_master.request.frame, g_master.request.length);
"141
[e ( _rs485_writeBytes (2 , -> &U . . _g_master 1 0 `*Cuc . . _g_master 1 1 ]
[; ;app_modbus.c: 142: return 1;
"142
[e ) -> -> 1 `i `uc ]
[e $UE 53  ]
[; ;app_modbus.c: 143: }
"143
[e :UE 53 ]
}
"146
[v _modbus_relay_status `(uc ~T0 @X0 1 sf ]
"147
{
[; ;app_modbus.c: 146: static bool modbus_relay_status(void)
[; ;app_modbus.c: 147: {
[e :U _modbus_relay_status ]
[f ]
[; ;app_modbus.c: 148: g_modbus.relay_status = RLY_NONE;
"148
[e = . _g_modbus 7 . `E599 0 ]
"149
[v _err `E164 ~T0 @X0 1 a ]
[; ;app_modbus.c: 149: ModbusError err = modbusBuildRequest01(&g_master, g_nvm.flash.ctrl_slave_id,
[; ;app_modbus.c: 150: 600, 0x0008);
"150
[e = _err ( _modbusBuildRequest01 (4 , , , &U _g_master . . . _g_nvm 0 1 4 -> -> 600 `i `ui -> -> 8 `i `ui ]
[; ;app_modbus.c: 151: if (err != MODBUS_OK) {
"151
[e $ ! != -> _err `i -> . `E164 7 `i 56  ]
{
[; ;app_modbus.c: 152: return 0;
"152
[e ) -> -> 0 `i `uc ]
[e $UE 55  ]
"153
}
[e :U 56 ]
[; ;app_modbus.c: 153: }
[; ;app_modbus.c: 159: rs485_writeBytes(g_master.request.frame, g_master.request.length);
"159
[e ( _rs485_writeBytes (2 , -> &U . . _g_master 1 0 `*Cuc . . _g_master 1 1 ]
[; ;app_modbus.c: 160: return 1;
"160
[e ) -> -> 1 `i `uc ]
[e $UE 55  ]
[; ;app_modbus.c: 161: }
"161
[e :UE 55 ]
}
"164
[v _modbus_check_threshold `(E595 ~T0 @X0 1 sf1`Cf ]
"165
{
[; ;app_modbus.c: 164: static e_EventType modbus_check_threshold(const float ppm)
[; ;app_modbus.c: 165: {
[e :U _modbus_check_threshold ]
"164
[v _ppm `Cf ~T0 @X0 1 r1 ]
"165
[f ]
"166
[v _max `f ~T0 @X0 1 a ]
[; ;app_modbus.c: 166: float max = g_nvm.flash.ctrl_ppm_max;
[e = _max . . . _g_nvm 0 1 6 ]
"168
[v _type `E595 ~T0 @X0 1 a ]
[; ;app_modbus.c: 168: e_EventType type = EV_NORMAL;
[e = _type . `E595 0 ]
[; ;app_modbus.c: 169: if (ppm > max) {
"169
[e $ ! > _ppm _max 58  ]
{
[; ;app_modbus.c: 170: type = EV_UP;
"170
[e = _type . `E595 1 ]
"171
}
[e :U 58 ]
[; ;app_modbus.c: 171: }
[; ;app_modbus.c: 172: return type;
"172
[e ) _type ]
[e $UE 57  ]
[; ;app_modbus.c: 173: }
"173
[e :UE 57 ]
}
"176
[v _modbus_check_event `(v ~T0 @X0 1 sf1`CE595 ]
"177
{
[; ;app_modbus.c: 176: static void modbus_check_event(const e_EventType type)
[; ;app_modbus.c: 177: {
[e :U _modbus_check_event ]
"176
[v _type `CE595 ~T0 @X0 1 r1 ]
"177
[f ]
[; ;app_modbus.c: 178: if (g_modbus.last_event != type) {
"178
[e $ ! != -> . _g_modbus 6 `i -> _type `i 60  ]
{
[; ;app_modbus.c: 179: g_modbus.last_event = type;
"179
[e = . _g_modbus 6 _type ]
[; ;app_modbus.c: 180: g_modbus.event_flag = 1;
"180
[e = . _g_modbus 2 -> -> 1 `i `uc ]
[; ;app_modbus.c: 181: g_modbus.event_timer = 0;
"181
[e = . _g_modbus 5 -> -> -> 0 `i `l `ul ]
"182
}
[e :U 60 ]
[; ;app_modbus.c: 182: }
[; ;app_modbus.c: 183: if (g_modbus.event_flag) {
"183
[e $ ! != -> . _g_modbus 2 `i -> -> -> 0 `i `uc `i 61  ]
{
[; ;app_modbus.c: 184: g_modbus.event_timer++;
"184
[e ++ . _g_modbus 5 -> -> -> 1 `i `l `ul ]
[; ;app_modbus.c: 189: if (g_modbus.event_timer >= g_nvm.flash.ctrl_holding_min * 60) {
"189
[e $ ! >= . _g_modbus 5 * . . . _g_nvm 0 1 7 -> -> -> 60 `i `l `ul 62  ]
{
[; ;app_modbus.c: 190: g_modbus.event_timer = 0;
"190
[e = . _g_modbus 5 -> -> -> 0 `i `l `ul ]
[; ;app_modbus.c: 191: g_modbus.event_flag = 0;
"191
[e = . _g_modbus 2 -> -> 0 `i `uc ]
[; ;app_modbus.c: 192: g_modbus.fire_flag = 1;
"192
[e = . _g_modbus 3 -> -> 1 `i `uc ]
"193
}
[e :U 62 ]
"194
}
[e :U 61 ]
[; ;app_modbus.c: 193: }
[; ;app_modbus.c: 194: }
[; ;app_modbus.c: 195: }
"195
[e :UE 59 ]
}
"198
[v _modbus_fire_event `(v ~T0 @X0 1 sf ]
"199
{
[; ;app_modbus.c: 198: static void modbus_fire_event(void)
[; ;app_modbus.c: 199: {
[e :U _modbus_fire_event ]
[f ]
[; ;app_modbus.c: 200: modbus_relay_ouput(g_nvm.flash.ctrl_relay_no, (g_modbus.last_event==EV_UP)?1:0);
"200
[e ( _modbus_relay_ouput (2 , . . . _g_nvm 0 1 5 -> ? == -> . _g_modbus 6 `i -> . `E595 1 `i : -> 1 `i -> 0 `i `uc ]
[; ;app_modbus.c: 201: }
"201
[e :UE 63 ]
}
"204
[v _modbus_master_response_parse `(v ~T0 @X0 1 sf ]
"205
{
[; ;app_modbus.c: 204: static void modbus_master_response_parse(void)
[; ;app_modbus.c: 205: {
[e :U _modbus_master_response_parse ]
[f ]
"206
[v _idx `uc ~T0 @X0 1 a ]
[; ;app_modbus.c: 206: uint8_t idx = ((g_nvm.flash.ctrl_relay_no - 1) < 0)?0:(g_nvm.flash.ctrl_relay_no - 1);
[e = _idx -> ? < - -> . . . _g_nvm 0 1 5 `i -> 1 `i -> 0 `i : -> 0 `i - -> . . . _g_nvm 0 1 5 `i -> 1 `i `uc ]
[; ;app_modbus.c: 207: switch (g_master.data.function) {
"207
[e $U 66  ]
{
[; ;app_modbus.c: 209: case 0x01:
"209
[e :U 67 ]
[; ;app_modbus.c: 210: if (g_modbus.fire_flag == 0 && g_modbus.event_flag == 0) {
"210
[e $ ! && == -> . _g_modbus 3 `i -> 0 `i == -> . _g_modbus 2 `i -> 0 `i 68  ]
{
[; ;app_modbus.c: 211: if ((g_master.data.coils[0] >> idx) & 0x01) {
"211
[e $ ! != & >> -> *U + &U . . . _g_master 3 6 0 * -> -> -> 0 `i `ui `ux -> -> # *U &U . . . _g_master 3 6 0 `ui `ux `i _idx -> 1 `i -> 0 `i 69  ]
{
[; ;app_modbus.c: 212: if (g_modbus.last_event == EV_NORMAL && g_modbus.relay_status != RLY_OPEN) {
"212
[e $ ! && == -> . _g_modbus 6 `i -> . `E595 0 `i != -> . _g_modbus 7 `i -> . `E599 1 `i 70  ]
{
[; ;app_modbus.c: 213: modbus_fire_event();
"213
[e ( _modbus_fire_event ..  ]
"214
}
[e :U 70 ]
"215
}
[; ;app_modbus.c: 214: }
[; ;app_modbus.c: 215: } else {
[e $U 71  ]
[e :U 69 ]
{
[; ;app_modbus.c: 216: if (g_modbus.last_event == EV_UP && g_modbus.relay_status != RLY_SHORT) {
"216
[e $ ! && == -> . _g_modbus 6 `i -> . `E595 1 `i != -> . _g_modbus 7 `i -> . `E599 2 `i 72  ]
{
[; ;app_modbus.c: 217: modbus_fire_event();
"217
[e ( _modbus_fire_event ..  ]
"218
}
[e :U 72 ]
"219
}
[e :U 71 ]
"220
}
[e :U 68 ]
[; ;app_modbus.c: 218: }
[; ;app_modbus.c: 219: }
[; ;app_modbus.c: 220: }
[; ;app_modbus.c: 221: break;
"221
[e $U 65  ]
[; ;app_modbus.c: 223: case 0x05:
"223
[e :U 73 ]
[; ;app_modbus.c: 224: if (g_modbus.last_event == EV_NORMAL) {
"224
[e $ ! == -> . _g_modbus 6 `i -> . `E595 0 `i 74  ]
{
[; ;app_modbus.c: 225: if (g_master.data.coils[0] == 0) {
"225
[e $ ! == -> *U + &U . . . _g_master 3 6 0 * -> -> -> 0 `i `ui `ux -> -> # *U &U . . . _g_master 3 6 0 `ui `ux `i -> 0 `i 75  ]
{
[; ;app_modbus.c: 226: g_modbus.relay_status = RLY_OPEN;
"226
[e = . _g_modbus 7 . `E599 1 ]
[; ;app_modbus.c: 227: g_modbus.fire_flag = 0;
"227
[e = . _g_modbus 3 -> -> 0 `i `uc ]
[; ;app_modbus.c: 228: g_modbus.fire_retry = 0;
"228
[e = . _g_modbus 4 -> -> 0 `i `uc ]
"229
}
[e :U 75 ]
"230
}
[; ;app_modbus.c: 229: }
[; ;app_modbus.c: 230: }
[e $U 76  ]
"231
[e :U 74 ]
[; ;app_modbus.c: 231: else if (g_modbus.last_event == EV_UP) {
[e $ ! == -> . _g_modbus 6 `i -> . `E595 1 `i 77  ]
{
[; ;app_modbus.c: 232: if (g_master.data.coils[0] != 0) {
"232
[e $ ! != -> *U + &U . . . _g_master 3 6 0 * -> -> -> 0 `i `ui `ux -> -> # *U &U . . . _g_master 3 6 0 `ui `ux `i -> 0 `i 78  ]
{
[; ;app_modbus.c: 233: g_modbus.relay_status = RLY_SHORT;
"233
[e = . _g_modbus 7 . `E599 2 ]
[; ;app_modbus.c: 234: g_modbus.fire_flag = 0;
"234
[e = . _g_modbus 3 -> -> 0 `i `uc ]
[; ;app_modbus.c: 235: g_modbus.fire_retry = 0;
"235
[e = . _g_modbus 4 -> -> 0 `i `uc ]
"236
}
[e :U 78 ]
"237
}
[e :U 77 ]
"238
[e :U 76 ]
[; ;app_modbus.c: 236: }
[; ;app_modbus.c: 237: }
[; ;app_modbus.c: 238: break;
[e $U 65  ]
"239
}
[; ;app_modbus.c: 239: }
[e $U 65  ]
"207
[e :U 66 ]
[e [\ . . _g_master 3 5 , $ -> -> 1 `i `uc 67
 , $ -> -> 5 `i `uc 73
 65 ]
"239
[e :U 65 ]
[; ;app_modbus.c: 240: }
"240
[e :UE 64 ]
}
"242
[v _modbus_master_relay_status_task `(v ~T0 @X0 1 sf ]
"243
{
[; ;app_modbus.c: 242: static void modbus_master_relay_status_task(void)
[; ;app_modbus.c: 243: {
[e :U _modbus_master_relay_status_task ]
[f ]
[; ;app_modbus.c: 244: if (g_relay_status_count >= 1000) {
"244
[e $ ! >= _g_relay_status_count -> -> 1000 `i `ui 80  ]
{
[; ;app_modbus.c: 245: g_relay_status_count = 0;
"245
[e = _g_relay_status_count -> -> 0 `i `ui ]
[; ;app_modbus.c: 246: if (g_modbus.fire_flag == 0 && g_modbus.event_flag == 0) {
"246
[e $ ! && == -> . _g_modbus 3 `i -> 0 `i == -> . _g_modbus 2 `i -> 0 `i 81  ]
{
[; ;app_modbus.c: 247: modbus_relay_status();
"247
[e ( _modbus_relay_status ..  ]
"248
}
[e :U 81 ]
"249
}
[e :U 80 ]
[; ;app_modbus.c: 248: }
[; ;app_modbus.c: 249: }
[; ;app_modbus.c: 250: }
"250
[e :UE 79 ]
}
"253
[v _modbus_master_relay_control_task `(v ~T0 @X0 1 sf ]
"254
{
[; ;app_modbus.c: 253: static void modbus_master_relay_control_task(void)
[; ;app_modbus.c: 254: {
[e :U _modbus_master_relay_control_task ]
[f ]
"255
[v _ppm `f ~T0 @X0 1 a ]
[; ;app_modbus.c: 255: float ppm;
[; ;app_modbus.c: 256: if (g_relay_sec_count >= 100) {
"256
[e $ ! >= _g_relay_sec_count -> -> 100 `i `ui 83  ]
{
[; ;app_modbus.c: 257: g_relay_sec_count = 0;
"257
[e = _g_relay_sec_count -> -> 0 `i `ui ]
[; ;app_modbus.c: 261: ppm = g_modbus_value.float_value[g_nvm.flash.ctrl_channel];
"261
[e = _ppm *U + &U . _g_modbus_value 1 * -> . . . _g_nvm 0 1 3 `ux -> -> # *U &U . _g_modbus_value 1 `ui `ux ]
[; ;app_modbus.c: 263: modbus_check_event(modbus_check_threshold(ppm));
"263
[e ( _modbus_check_event (1 ( _modbus_check_threshold (1 _ppm ]
[; ;app_modbus.c: 265: if (g_modbus.fire_flag) {
"265
[e $ ! != -> . _g_modbus 3 `i -> -> -> 0 `i `uc `i 84  ]
{
[; ;app_modbus.c: 266: if (g_modbus.fire_retry >= 3) {
"266
[e $ ! >= -> . _g_modbus 4 `i -> 3 `i 85  ]
{
[; ;app_modbus.c: 267: g_modbus.fire_flag = 0;
"267
[e = . _g_modbus 3 -> -> 0 `i `uc ]
[; ;app_modbus.c: 268: g_modbus.fire_retry = 0;
"268
[e = . _g_modbus 4 -> -> 0 `i `uc ]
[; ;app_modbus.c: 269: return;
"269
[e $UE 82  ]
"270
}
[e :U 85 ]
[; ;app_modbus.c: 270: }
[; ;app_modbus.c: 271: modbus_fire_event();
"271
[e ( _modbus_fire_event ..  ]
[; ;app_modbus.c: 272: g_modbus.fire_retry++;
"272
[e ++ . _g_modbus 4 -> -> 1 `i `uc ]
"273
}
[e :U 84 ]
"274
}
[e :U 83 ]
[; ;app_modbus.c: 273: }
[; ;app_modbus.c: 274: }
[; ;app_modbus.c: 275: }
"275
[e :UE 82 ]
}
"278
[v _modbus_master_task `(v ~T0 @X0 1 sf ]
"279
{
[; ;app_modbus.c: 278: static void modbus_master_task(void)
[; ;app_modbus.c: 279: {
[e :U _modbus_master_task ]
[f ]
"280
[v _byte `uc ~T0 @X0 1 a ]
[; ;app_modbus.c: 280: uint8_t byte;
[; ;app_modbus.c: 282: switch (g_modbus.seq) {
"282
[e $U 88  ]
{
[; ;app_modbus.c: 283: case MODBUS_INIT:
"283
[e :U 89 ]
[; ;app_modbus.c: 284: modbus_init();
"284
[e ( _modbus_init ..  ]
[; ;app_modbus.c: 285: g_timeout_count = 0;
"285
[e = _g_timeout_count -> -> 0 `i `uc ]
[; ;app_modbus.c: 286: g_modbus.seq = MODBUS_READY;
"286
[e = . _g_modbus 0 -> . `E570 1 `uc ]
[; ;app_modbus.c: 287: break;
"287
[e $U 87  ]
[; ;app_modbus.c: 288: case MODBUS_READY:
"288
[e :U 90 ]
[; ;app_modbus.c: 289: if (buffer_de_queue_bool(&g_modbus_queue, &byte)) {
"289
[e $ ! != -> ( _buffer_de_queue_bool (2 , &U _g_modbus_queue &U _byte `i -> -> -> 0 `i `uc `i 91  ]
{
[; ;app_modbus.c: 290: g_timeout_count = 0;
"290
[e = _g_timeout_count -> -> 0 `i `uc ]
[; ;app_modbus.c: 291: if (byte == g_nvm.flash.ctrl_slave_id && g_master.predictedResponseLength > 0) {
"291
[e $ ! && == -> _byte `i -> . . . _g_nvm 0 1 4 `i > -> . _g_master 0 `i -> 0 `i 92  ]
{
[; ;app_modbus.c: 292: g_master.response.length = 0;
"292
[e = . . _g_master 2 1 -> -> 0 `i `uc ]
[; ;app_modbus.c: 293: g_master.response.frame[g_master.response.length++] = byte;
"293
[e = *U + &U . . _g_master 2 0 * -> ++ . . _g_master 2 1 -> -> 1 `i `uc `ux -> -> # *U &U . . _g_master 2 0 `ui `ux _byte ]
[; ;app_modbus.c: 294: g_modbus.seq = MODBUS_START;
"294
[e = . _g_modbus 0 -> . `E570 2 `uc ]
"295
}
[e :U 92 ]
"296
}
[e :U 91 ]
[; ;app_modbus.c: 295: }
[; ;app_modbus.c: 296: }
[; ;app_modbus.c: 297: break;
"297
[e $U 87  ]
[; ;app_modbus.c: 298: case MODBUS_START:
"298
[e :U 93 ]
[; ;app_modbus.c: 299: if (buffer_de_queue_bool(&g_modbus_queue, &byte)) {
"299
[e $ ! != -> ( _buffer_de_queue_bool (2 , &U _g_modbus_queue &U _byte `i -> -> -> 0 `i `uc `i 94  ]
{
[; ;app_modbus.c: 300: g_timeout_count = 0;
"300
[e = _g_timeout_count -> -> 0 `i `uc ]
[; ;app_modbus.c: 301: g_master.response.frame[g_master.response.length++] = byte;
"301
[e = *U + &U . . _g_master 2 0 * -> ++ . . _g_master 2 1 -> -> 1 `i `uc `ux -> -> # *U &U . . _g_master 2 0 `ui `ux _byte ]
[; ;app_modbus.c: 302: if (g_master.response.length >= g_master.predictedResponseLength) {
"302
[e $ ! >= -> . . _g_master 2 1 `i -> . _g_master 0 `i 95  ]
{
[; ;app_modbus.c: 303: switch (modbusParseResponse(&g_master)) {
"303
[e $U 97  ]
{
[; ;app_modbus.c: 305: case MODBUS_OK:
"305
[e :U 98 ]
[; ;app_modbus.c: 306: g_modbus.seq = MODBUS_OUTPUT;
"306
[e = . _g_modbus 0 -> . `E570 4 `uc ]
[; ;app_modbus.c: 307: break;
"307
[e $U 96  ]
[; ;app_modbus.c: 309: case MODBUS_ERROR_EXCEPTION:
"309
[e :U 99 ]
"310
[e :U 100 ]
"311
[e :U 101 ]
[; ;app_modbus.c: 310: case MODBUS_ERROR_PARSE:
[; ;app_modbus.c: 311: case MODBUS_ERROR_BUILD:
[; ;app_modbus.c: 312: g_modbus.seq = MODBUS_EXCEPTION;
"312
[e = . _g_modbus 0 -> . `E570 6 `uc ]
[; ;app_modbus.c: 313: break;
"313
[e $U 96  ]
[; ;app_modbus.c: 315: case MODBUS_ERROR_ALLOC:
"315
[e :U 102 ]
"316
[e :U 103 ]
"317
[e :U 104 ]
[; ;app_modbus.c: 316: case MODBUS_ERROR_OTHER:
[; ;app_modbus.c: 317: case MODBUS_ERROR_NULLPTR:
[; ;app_modbus.c: 318: g_modbus.seq = MODBUS_END;
"318
[e = . _g_modbus 0 -> . `E570 7 `uc ]
[; ;app_modbus.c: 319: break;
"319
[e $U 96  ]
"320
}
[; ;app_modbus.c: 320: }
[e $U 96  ]
"303
[e :U 97 ]
[e [\ ( _modbusParseResponse (1 &U _g_master , $ . `E164 7 98
 , $ . `E164 1 99
 , $ . `E164 5 100
 , $ . `E164 6 101
 , $ . `E164 2 102
 , $ . `E164 3 103
 , $ . `E164 4 104
 96 ]
"320
[e :U 96 ]
"321
}
[e :U 95 ]
"322
}
[; ;app_modbus.c: 321: }
[; ;app_modbus.c: 322: } else {
[e $U 105  ]
[e :U 94 ]
{
[; ;app_modbus.c: 323: if (g_timeout_count > g_modbus.timeout) {
"323
[e $ ! > -> _g_timeout_count `i -> . _g_modbus 1 `i 106  ]
{
[; ;app_modbus.c: 324: g_modbus.seq = MODBUS_TIMEOUT;
"324
[e = . _g_modbus 0 -> . `E570 3 `uc ]
"325
}
[e :U 106 ]
"326
}
[e :U 105 ]
[; ;app_modbus.c: 325: }
[; ;app_modbus.c: 326: }
[; ;app_modbus.c: 327: break;
"327
[e $U 87  ]
[; ;app_modbus.c: 328: case MODBUS_TIMEOUT:
"328
[e :U 107 ]
[; ;app_modbus.c: 329: g_modbus.seq = MODBUS_END;
"329
[e = . _g_modbus 0 -> . `E570 7 `uc ]
[; ;app_modbus.c: 330: break;
"330
[e $U 87  ]
[; ;app_modbus.c: 331: case MODBUS_OUTPUT:
"331
[e :U 108 ]
[; ;app_modbus.c: 332: {
"332
{
[; ;app_modbus.c: 343: modbus_master_response_parse();
"343
[e ( _modbus_master_response_parse ..  ]
[; ;app_modbus.c: 344: g_modbus.seq = MODBUS_END;
"344
[e = . _g_modbus 0 -> . `E570 7 `uc ]
"345
}
[; ;app_modbus.c: 345: }
[; ;app_modbus.c: 346: break;
"346
[e $U 87  ]
[; ;app_modbus.c: 347: case MODBUS_EXCEPTION:
"347
[e :U 109 ]
[; ;app_modbus.c: 358: g_modbus.seq = MODBUS_END;
"358
[e = . _g_modbus 0 -> . `E570 7 `uc ]
[; ;app_modbus.c: 359: break;
"359
[e $U 87  ]
[; ;app_modbus.c: 360: case MODBUS_END:
"360
[e :U 110 ]
[; ;app_modbus.c: 361: modbusMasterEnd(&g_master);
"361
[e ( _modbusMasterEnd (1 &U _g_master ]
[; ;app_modbus.c: 362: g_timeout_count = 0;
"362
[e = _g_timeout_count -> -> 0 `i `uc ]
[; ;app_modbus.c: 363: g_modbus.seq = MODBUS_READY;
"363
[e = . _g_modbus 0 -> . `E570 1 `uc ]
[; ;app_modbus.c: 364: break;
"364
[e $U 87  ]
"365
}
[; ;app_modbus.c: 365: }
[e $U 87  ]
"282
[e :U 88 ]
[e [\ . _g_modbus 0 , $ -> . `E570 0 `uc 89
 , $ -> . `E570 1 `uc 90
 , $ -> . `E570 2 `uc 93
 , $ -> . `E570 3 `uc 107
 , $ -> . `E570 4 `uc 108
 , $ -> . `E570 6 `uc 109
 , $ -> . `E570 7 `uc 110
 87 ]
"365
[e :U 87 ]
[; ;app_modbus.c: 366: }
"366
[e :UE 86 ]
}
"369
[v _modbus_slave_task `(v ~T0 @X0 1 sf ]
"370
{
[; ;app_modbus.c: 369: static void modbus_slave_task(void)
[; ;app_modbus.c: 370: {
[e :U _modbus_slave_task ]
[f ]
"371
[v _byte `uc ~T0 @X0 1 a ]
[; ;app_modbus.c: 371: uint8_t byte;
[; ;app_modbus.c: 373: switch (g_modbus.seq) {
"373
[e $U 113  ]
{
[; ;app_modbus.c: 374: case MODBUS_INIT:
"374
[e :U 114 ]
[; ;app_modbus.c: 375: modbus_init();
"375
[e ( _modbus_init ..  ]
[; ;app_modbus.c: 376: g_timeout_count = 0;
"376
[e = _g_timeout_count -> -> 0 `i `uc ]
[; ;app_modbus.c: 377: g_modbus.seq = MODBUS_READY;
"377
[e = . _g_modbus 0 -> . `E570 1 `uc ]
[; ;app_modbus.c: 378: break;
"378
[e $U 112  ]
[; ;app_modbus.c: 379: case MODBUS_READY:
"379
[e :U 115 ]
[; ;app_modbus.c: 380: if (buffer_de_queue_bool(&g_modbus_queue, &byte)) {
"380
[e $ ! != -> ( _buffer_de_queue_bool (2 , &U _g_modbus_queue &U _byte `i -> -> -> 0 `i `uc `i 116  ]
{
[; ;app_modbus.c: 381: g_timeout_count = 0;
"381
[e = _g_timeout_count -> -> 0 `i `uc ]
[; ;app_modbus.c: 382: if (byte == g_slave.address) {
"382
[e $ ! == -> _byte `i -> . _g_slave 0 `i 117  ]
{
[; ;app_modbus.c: 383: g_slave.request.length = 0;
"383
[e = . . _g_slave 16 1 -> -> 0 `i `uc ]
[; ;app_modbus.c: 384: g_slave.request.frame[g_slave.request.length++] = byte;
"384
[e = *U + &U . . _g_slave 16 0 * -> ++ . . _g_slave 16 1 -> -> 1 `i `uc `ux -> -> # *U &U . . _g_slave 16 0 `ui `ux _byte ]
[; ;app_modbus.c: 385: g_modbus.seq = MODBUS_START;
"385
[e = . _g_modbus 0 -> . `E570 2 `uc ]
"386
}
[e :U 117 ]
"387
}
[e :U 116 ]
[; ;app_modbus.c: 386: }
[; ;app_modbus.c: 387: }
[; ;app_modbus.c: 388: break;
"388
[e $U 112  ]
[; ;app_modbus.c: 389: case MODBUS_START:
"389
[e :U 118 ]
[; ;app_modbus.c: 390: if (buffer_de_queue_bool(&g_modbus_queue, &byte)) {
"390
[e $ ! != -> ( _buffer_de_queue_bool (2 , &U _g_modbus_queue &U _byte `i -> -> -> 0 `i `uc `i 119  ]
{
[; ;app_modbus.c: 391: g_timeout_count = 0;
"391
[e = _g_timeout_count -> -> 0 `i `uc ]
[; ;app_modbus.c: 392: g_slave.request.frame[g_slave.request.length++] = byte;
"392
[e = *U + &U . . _g_slave 16 0 * -> ++ . . _g_slave 16 1 -> -> 1 `i `uc `ux -> -> # *U &U . . _g_slave 16 0 `ui `ux _byte ]
[; ;app_modbus.c: 393: if (g_slave.request.length >= 8) {
"393
[e $ ! >= -> . . _g_slave 16 1 `i -> 8 `i 120  ]
{
[; ;app_modbus.c: 394: switch (modbusParseRequest(&g_slave)) {
"394
[e $U 122  ]
{
[; ;app_modbus.c: 396: case MODBUS_OK:
"396
[e :U 123 ]
[; ;app_modbus.c: 397: g_modbus.seq = MODBUS_OUTPUT;
"397
[e = . _g_modbus 0 -> . `E570 4 `uc ]
[; ;app_modbus.c: 398: break;
"398
[e $U 121  ]
[; ;app_modbus.c: 400: case MODBUS_ERROR_EXCEPTION:
"400
[e :U 124 ]
"401
[e :U 125 ]
"402
[e :U 126 ]
[; ;app_modbus.c: 401: case MODBUS_ERROR_PARSE:
[; ;app_modbus.c: 402: case MODBUS_ERROR_BUILD:
[; ;app_modbus.c: 403: g_modbus.seq = MODBUS_EXCEPTION;
"403
[e = . _g_modbus 0 -> . `E570 6 `uc ]
[; ;app_modbus.c: 404: break;
"404
[e $U 121  ]
[; ;app_modbus.c: 406: case MODBUS_ERROR_ALLOC:
"406
[e :U 127 ]
"407
[e :U 128 ]
"408
[e :U 129 ]
[; ;app_modbus.c: 407: case MODBUS_ERROR_OTHER:
[; ;app_modbus.c: 408: case MODBUS_ERROR_NULLPTR:
[; ;app_modbus.c: 409: g_modbus.seq = MODBUS_END;
"409
[e = . _g_modbus 0 -> . `E570 7 `uc ]
[; ;app_modbus.c: 410: break;
"410
[e $U 121  ]
"411
}
[; ;app_modbus.c: 411: }
[e $U 121  ]
"394
[e :U 122 ]
[e [\ ( _modbusParseRequest (1 &U _g_slave , $ . `E164 7 123
 , $ . `E164 1 124
 , $ . `E164 5 125
 , $ . `E164 6 126
 , $ . `E164 2 127
 , $ . `E164 3 128
 , $ . `E164 4 129
 121 ]
"411
[e :U 121 ]
"412
}
[e :U 120 ]
"413
}
[; ;app_modbus.c: 412: }
[; ;app_modbus.c: 413: } else {
[e $U 130  ]
[e :U 119 ]
{
[; ;app_modbus.c: 414: if (g_timeout_count > g_modbus.timeout) {
"414
[e $ ! > -> _g_timeout_count `i -> . _g_modbus 1 `i 131  ]
{
[; ;app_modbus.c: 415: g_modbus.seq = MODBUS_TIMEOUT;
"415
[e = . _g_modbus 0 -> . `E570 3 `uc ]
"416
}
[e :U 131 ]
"417
}
[e :U 130 ]
[; ;app_modbus.c: 416: }
[; ;app_modbus.c: 417: }
[; ;app_modbus.c: 418: break;
"418
[e $U 112  ]
[; ;app_modbus.c: 419: case MODBUS_TIMEOUT:
"419
[e :U 132 ]
[; ;app_modbus.c: 420: g_modbus.seq = MODBUS_END;
"420
[e = . _g_modbus 0 -> . `E570 7 `uc ]
[; ;app_modbus.c: 421: break;
"421
[e $U 112  ]
[; ;app_modbus.c: 422: case MODBUS_OUTPUT:
"422
[e :U 133 ]
[; ;app_modbus.c: 423: rs485_writeBytes(g_slave.response.frame, g_slave.response.length);
"423
[e ( _rs485_writeBytes (2 , -> &U . . _g_slave 15 0 `*Cuc . . _g_slave 15 1 ]
[; ;app_modbus.c: 424: g_modbus.seq = MODBUS_END;
"424
[e = . _g_modbus 0 -> . `E570 7 `uc ]
[; ;app_modbus.c: 425: break;
"425
[e $U 112  ]
[; ;app_modbus.c: 426: case MODBUS_EXCEPTION:
"426
[e :U 134 ]
[; ;app_modbus.c: 435: g_modbus.seq = MODBUS_END;
"435
[e = . _g_modbus 0 -> . `E570 7 `uc ]
[; ;app_modbus.c: 436: break;
"436
[e $U 112  ]
[; ;app_modbus.c: 437: case MODBUS_END:
"437
[e :U 135 ]
[; ;app_modbus.c: 438: modbusSlaveEnd(&g_slave);
"438
[e ( _modbusSlaveEnd (1 &U _g_slave ]
[; ;app_modbus.c: 439: g_timeout_count = 0;
"439
[e = _g_timeout_count -> -> 0 `i `uc ]
[; ;app_modbus.c: 440: g_modbus.seq = MODBUS_READY;
"440
[e = . _g_modbus 0 -> . `E570 1 `uc ]
[; ;app_modbus.c: 441: break;
"441
[e $U 112  ]
"442
}
[; ;app_modbus.c: 442: }
[e $U 112  ]
"373
[e :U 113 ]
[e [\ . _g_modbus 0 , $ -> . `E570 0 `uc 114
 , $ -> . `E570 1 `uc 115
 , $ -> . `E570 2 `uc 118
 , $ -> . `E570 3 `uc 132
 , $ -> . `E570 4 `uc 133
 , $ -> . `E570 6 `uc 134
 , $ -> . `E570 7 `uc 135
 112 ]
"442
[e :U 112 ]
[; ;app_modbus.c: 443: }
"443
[e :UE 111 ]
}
"445
[v _modbus_task `(v ~T0 @X0 1 ef ]
"446
{
[; ;app_modbus.c: 445: void modbus_task(void)
[; ;app_modbus.c: 446: {
[e :U _modbus_task ]
[f ]
[; ;app_modbus.c: 447: if (g_nvm.flash.sensing_on == SENSING_ON) {
"447
[e $ ! == -> . . . _g_nvm 0 1 1 `i -> . `E92 1 `i 137  ]
{
[; ;app_modbus.c: 448: if (g_nvm.flash.ctrl_master_mode == MODBUS_MASTER_MODE) {
"448
[e $ ! == -> . . . _g_nvm 0 1 2 `i -> . `E110 1 `i 138  ]
{
[; ;app_modbus.c: 449: modbus_master_task();
"449
[e ( _modbus_master_task ..  ]
[; ;app_modbus.c: 450: if (g_modbus.isWarmDone) {
"450
[e $ ! != -> . _g_modbus 8 `i -> -> -> 0 `i `uc `i 139  ]
{
[; ;app_modbus.c: 451: modbus_master_relay_control_task();
"451
[e ( _modbus_master_relay_control_task ..  ]
"452
}
[; ;app_modbus.c: 452: } else {
[e $U 140  ]
[e :U 139 ]
{
[; ;app_modbus.c: 453: if (g_relay_sec_count >= 18000) {
"453
[e $ ! >= _g_relay_sec_count -> -> 18000 `i `ui 141  ]
{
[; ;app_modbus.c: 454: g_relay_sec_count = 0;
"454
[e = _g_relay_sec_count -> -> 0 `i `ui ]
[; ;app_modbus.c: 455: g_modbus.isWarmDone = 1;
"455
[e = . _g_modbus 8 -> -> 1 `i `uc ]
"456
}
[e :U 141 ]
"457
}
[e :U 140 ]
[; ;app_modbus.c: 456: }
[; ;app_modbus.c: 457: }
[; ;app_modbus.c: 458: modbus_master_relay_status_task();
"458
[e ( _modbus_master_relay_status_task ..  ]
"459
}
[; ;app_modbus.c: 459: } else {
[e $U 142  ]
[e :U 138 ]
{
[; ;app_modbus.c: 460: modbus_slave_task();
"460
[e ( _modbus_slave_task ..  ]
"461
}
[e :U 142 ]
"462
}
[e :U 137 ]
[; ;app_modbus.c: 461: }
[; ;app_modbus.c: 462: }
[; ;app_modbus.c: 463: }
"463
[e :UE 136 ]
}
